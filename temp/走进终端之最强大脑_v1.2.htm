<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<meta name=Generator content="Microsoft Word 12 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:微软雅黑;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Cambria;
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;}
@font-face
	{font-family:"\@微软雅黑";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Calibri","sans-serif";}
h2
	{mso-style-link:"标题 2 Char";
	margin-top:13.0pt;
	margin-right:0cm;
	margin-bottom:13.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:173%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Cambria","serif";}
h3
	{mso-style-link:"标题 3 Char";
	margin-top:13.0pt;
	margin-right:0cm;
	margin-bottom:13.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:173%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"页眉 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"页脚 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"标题 Char";
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-align:center;
	font-size:16.0pt;
	font-family:"Cambria","serif";
	font-weight:bold;}
p.MsoDocumentMap, li.MsoDocumentMap, div.MsoDocumentMap
	{mso-style-link:"文档结构图 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:9.0pt;
	font-family:微软雅黑;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"批注框文本 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	font-size:10.5pt;
	font-family:"Calibri","sans-serif";}
span.Char
	{mso-style-name:"页眉 Char";
	mso-style-link:页眉;}
span.Char0
	{mso-style-name:"页脚 Char";
	mso-style-link:页脚;}
span.Char1
	{mso-style-name:"标题 Char";
	mso-style-link:标题;
	font-family:"Cambria","serif";
	font-weight:bold;}
span.Char2
	{mso-style-name:"文档结构图 Char";
	mso-style-link:文档结构图;
	font-family:微软雅黑;}
span.2Char
	{mso-style-name:"标题 2 Char";
	mso-style-link:"标题 2";
	font-family:"Cambria","serif";
	font-weight:bold;}
span.3Char
	{mso-style-name:"标题 3 Char";
	mso-style-link:"标题 3";
	font-weight:bold;}
span.Char3
	{mso-style-name:"批注框文本 Char";
	mso-style-link:批注框文本;}
 /* Page Definitions */
 @page WordSection1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	layout-grid:15.6pt;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=ZH-CN style='text-justify-trim:punctuation'>

<div class=WordSection1 style='layout-grid:15.6pt'>

<p class=MsoTitle><span style='font-family:微软雅黑'>“走进终端”之最强大脑</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>中央处理器（</span><span lang=EN-US>CPU</span><span
style='font-family:微软雅黑'>）是终端的“大脑”。无论是玩游戏还跑应用，</span><span lang=EN-US>CPU</span><span
style='font-family:微软雅黑'>性能对用户体验起决定性作用。在本期的“走进终端”中，让我们走近</span><span lang=EN-US>CPU</span><span
style='font-family:微软雅黑'>，对其构造、原理一探究竟。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h2><span style='font-family:微软雅黑'>一、体系结构</span></h2>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h3><span style='font-family:微软雅黑'>冯・诺依曼结构</span></h3>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><a
href="http://a1.att.hudong.com/03/44/19300239842373132401447688758.jpg"
title="&quot;现代计算机之父――诺依曼&quot; t "><span style='color:windowtext;text-decoration:
none'><img border=0 width=133 height=144 src="走进终端之最强大脑_v1.2.files/image001.jpg"
alt="现代计算机之父――诺依曼"></span></a></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>1945</span><span style='font-family:微软雅黑'>年美国科学家冯・诺依曼在关于</span><span
lang=EN-US>EDVAC</span><span style='font-family:微软雅黑'>的</span><span lang=EN-US>101</span><span
style='font-family:微软雅黑'>页报告中提出了存储程序型计算机的概念。人们把利用这种概念和原理设计的电子计算机系统称为“冯・诺依曼结构”计算机。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><a
href="https://upload.wikimedia.org/wikipedia/commons/e/e5/Von_Neumann_Architecture.svg"><span
style='color:windowtext;text-decoration:none'><img border=0 width=363
height=210 src="走进终端之最强大脑_v1.2.files/image002.png"
alt="File:Von Neumann Architecture.svg"></span></a></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>冯・诺曼结构中，程序、数据使用同一个存储器，经由同一个总线传输，程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置。要知道，在这篇报告之前，如</span><span
lang=EN-US>ENIAC</span><span style='font-family:微软雅黑'>前辈，世界上最早的通用电子计算机之一，给它编程非常麻烦：在纸上设计完成程序设计后，用几天的时间拧开关、调整线缆，再花费十几天时间进行调试、验证。也就是说</span><span
lang=EN-US>ENIAC</span><span style='font-family:微软雅黑'>的程序是一种硬编码（</span><span
lang=EN-US>hard-coded</span><span style='font-family:微软雅黑'>），给它编程实际上就是调整各个计算模块的物理连接。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>从</span><span lang=EN-US>EDVAC</span><span
style='font-family:微软雅黑'>开始，到当前最先进的计算机都采用了冯・诺依曼体系结构，所以冯・诺依曼被称为数字计算机之父。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<div style='border:solid windowtext 2.25pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=MsoNormal style='border:none;padding:0cm'><b><span style='font-family:
微软雅黑'>八卦故事：</span></b><span style='font-family:微软雅黑'>冯・诺依曼撰写的</span><span
lang=EN-US>101</span><span style='font-family:微软雅黑'>页报告可谓是开山大作，但是</span><span
lang=EN-US>EDVAC</span><span style='font-family:微软雅黑'>设计团队中也有人认为存储程序这一概念产生于宾夕法尼亚大学摩尔电气工程学院的一次会议，冯・诺依曼的报告对这一概念做了形式化描述，但是对这次会议却并未提及，导致所有的贡献全归冯・诺依曼所有。“穷者愈穷，富者愈富”，这件事成了马太效应在学术圈的又一例证。</span></p>

</div>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>冯・诺依曼结构里，程序在运行过程中可以被改写，借此可以设计出极具灵活性的程序，但是也引入了很多新的问题，比如程序调试困难、安全隐患多等，所以现代操作系统对于存储区中的数据是否可作为程序执行作了限制。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h3><span style='font-family:微软雅黑'>哈佛结构</span></h3>

<p class=MsoNormal><span style='font-family:微软雅黑'>哈佛结构起源于哈佛</span><span
lang=EN-US>Mark I</span><span style='font-family:微软雅黑'>计算机。哈佛</span><span
lang=EN-US>Mark I</span><span style='font-family:微软雅黑'>的指令和数据是通过两条打孔纸带分别输入的，这种程序（指令）和数据独立存取的结构称为哈佛结构。这里的“哈佛”就是哈佛大学的哈佛。</span></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><img
border=0 width=408 height=259 id="图片 7" src="走进终端之最强大脑_v1.2.files/image003.png"
alt="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Harvard_architecture.svg/1024px-Harvard_architecture.svg.png"></span></p>

<div style='border:solid windowtext 2.25pt;padding:1.0pt 4.0pt 1.0pt 4.0pt'>

<p class=MsoNormal style='border:none;padding:0cm'><b><span style='font-family:
微软雅黑'>八卦故事：</span></b><span style='font-family:微软雅黑'>有趣的是，哈佛</span><span
lang=EN-US>Mark I</span><span style='font-family:微软雅黑'>计算机上最先运行的程序之一就是来自冯・诺依曼。当时正参与“曼哈顿计划”的冯・诺依曼在哈佛</span><span
lang=EN-US>Mark I</span><span style='font-family:微软雅黑'>计算机上进行模拟，发现内爆结构比枪式结构效果更好。美国在日本广岛投掷的“小男孩”为枪式起爆（</span><span
lang=EN-US>14000</span><span style='font-family:微软雅黑'>吨</span><span lang=EN-US>TNT</span><span
style='font-family:微软雅黑'>当量），而第二枚投掷在长崎的“胖子”即为内爆式起爆（</span><span lang=EN-US>20000</span><span
style='font-family:微软雅黑'>吨</span><span lang=EN-US>TNT</span><span
style='font-family:微软雅黑'>当量）。</span></p>

</div>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>哈佛结构里通过独立总线分别访问指令和数据存储，数据吞吐率较高，所以在数字信号处理器（</span><span
lang=EN-US>DSP</span><span style='font-family:微软雅黑'>）等对数据处理能力要求高的领域多采用哈佛结构。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>大创新很难，小创新却容易：</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:微软雅黑'>能不能把数据存储搞成两份？可以，这种指令、数据</span><span
lang=EN-US>1</span><span style='font-family:微软雅黑'>、数据</span><span lang=EN-US>2</span><span
style='font-family:微软雅黑'>分开存储，通过三条总线独立访问的结构称为“双哈佛结构”</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:微软雅黑'>能不能把指令存储搞成两份？醒醒！是要搞双核吧？</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:微软雅黑'>能不能把两种体系结构融为一炉？可以。事实上，我们现在所使用的桌面级或更高端的</span><span
lang=EN-US>x86 CPU</span><span style='font-family:微软雅黑'>宏观上是冯・诺依曼结构，而微观上则有哈佛结构的特点：</span><span
lang=EN-US>CPU</span><span style='font-family:微软雅黑'>内部都包含多级缓存（</span><span
lang=EN-US>cache</span><span style='font-family:微软雅黑'>），其中第一级缓存分为数据缓存和指令缓存，与哈佛结构类似。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h2><span style='font-family:微软雅黑'>二、指令集架构</span></h2>

<p class=MsoNormal><span style='font-family:微软雅黑'>从指令集架构看，现在主流的</span><span
lang=EN-US>CPU</span><span style='font-family:微软雅黑'>体系主要分为复杂指令集计算机（</span><span
lang=EN-US>CISC</span><span style='font-family:微软雅黑'>）和精减指令集计算机（</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>）两种。</span></p>

<h3><span lang=EN-US>CISC</span><span style='font-family:微软雅黑'>与</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>之争</span></h3>

<p class=MsoNormal><span lang=EN-US>CISC</span><span style='font-family:微软雅黑'>的代表是</span><span
lang=EN-US>x86/x64</span><span style='font-family:微软雅黑'>处理器，</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>的代表则是在移动端一统江湖的</span><span
lang=EN-US>ARM</span><span style='font-family:微软雅黑'>处理器。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>例如，将存储在地址</span><span
lang=EN-US>A</span><span style='font-family:微软雅黑'>的数与存储在地址</span><span
lang=EN-US>B</span><span style='font-family:微软雅黑'>的数据相乘，乘积保存到地址</span><span
lang=EN-US>A</span><span style='font-family:微软雅黑'>，对于这个任务，“急脾气”的</span><span
lang=EN-US>CISC</span><span style='font-family:微软雅黑'>用一条指令搞定：</span><span
lang=EN-US style='font-family:Consolas'>MULT [A], [B]</span><span
style='font-family:微软雅黑'>；而“慢性子”</span><span lang=EN-US>RISC</span><span
style='font-family:微软雅黑'>则要慢条斯理地用四条指令完成：</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:Consolas'>LOAD R0, [A]&nbsp; ;&nbsp;
</span><span style='font-family:微软雅黑'>将地址</span><span lang=EN-US
style='font-family:Consolas'>A</span><span style='font-family:微软雅黑'>的数加载到寄存器</span><span
lang=EN-US style='font-family:Consolas'> R0 </span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:Consolas'>LOAD R1, [B]&nbsp; ;&nbsp;
</span><span style='font-family:微软雅黑'>将地址</span><span lang=EN-US
style='font-family:Consolas'>B</span><span style='font-family:微软雅黑'>的数加载到寄存器</span><span
lang=EN-US style='font-family:Consolas'> R1</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:Consolas'>MULT R0, R1&nbsp;&nbsp; ;&nbsp;
</span><span style='font-family:微软雅黑'>两个寄存器中的数</span><span style='font-family:
微软雅黑'>相乘，结果保存在</span><span lang=EN-US style='font-family:Consolas'> R0</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:Consolas'>STORE [A], R0 ;&nbsp;
</span><span style='font-family:微软雅黑'>乘积保存到地址</span><span lang=EN-US
style='font-family:Consolas'>A</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>可以看出</span><span lang=EN-US>CISC</span><span
style='font-family:微软雅黑'>与</span><span lang=EN-US>RISC</span><span
style='font-family:微软雅黑'>之间存在诸多差异。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>CISC</span><span style='font-family:微软雅黑'>倚重硬件，通过硬件复杂度降低软件复杂度：</span><span
lang=EN-US>CISC</span><span style='font-family:微软雅黑'>指令灵活多样，比如上面的乘法，除了“</span><span
lang=EN-US>MULT [A], [B]</span><span style='font-family:微软雅黑'>”，还有直接在寄存器里计算的“</span><span
lang=EN-US>MULT AX, BX</span><span style='font-family:微软雅黑'>”等；</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>则倚重软件，仅提供必要指令，处理器硬件相对简单，软件长度、复杂度则相应提高</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>CISC</span><span style='font-family:微软雅黑'>指令一般需要多个机器周期才能执行完毕，而</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>指令一般一个机器周期即可完成</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>CISC</span><span style='font-family:微软雅黑'>指令相对复杂，支持立即寻址、寄存器寻址、直接地址、相对地址等多种寻址方式，而</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>指令则比较简单</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>CISC</span><span style='font-family:微软雅黑'>指令多，长度不一，比如</span><span
lang=EN-US>x86</span><span style='font-family:微软雅黑'>一条指令最短为</span><span
lang=EN-US>1</span><span style='font-family:微软雅黑'>字节，最长理论上可以无限长，只是实际设计处理器时会从硬件上对最大长度做出限制（如</span><span
lang=EN-US>15</span><span style='font-family:微软雅黑'>字节）；</span><span lang=EN-US>RISC</span><span
style='font-family:微软雅黑'>指令长度基本固定，绝大部分</span><span lang=EN-US>AMR</span><span
style='font-family:微软雅黑'>指令长度为</span><span lang=EN-US>4</span><span
style='font-family:微软雅黑'>字节，少部分指令长度为</span><span lang=EN-US>2</span><span
style='font-family:微软雅黑'>字节</span> </p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>RISC</span><span style='font-family:微软雅黑'>处理器晶体管数目少，成本、功耗低，适宜在手机、平板等低功耗、高移动性产品。在全球已累计生产了千亿颗</span><span
lang=EN-US>ARM</span><span style='font-family:微软雅黑'>处理器的背景下，</span><span
lang=EN-US>ARM</span><span style='font-family:微软雅黑'>公司正在积极寻找杀入高性能服务器市场的机会，而</span><span
lang=EN-US>Intel</span><span style='font-family:微软雅黑'>也锲而不舍地要把</span><span
lang=EN-US>x86</span><span style='font-family:微软雅黑'>体系推广到低功耗产品中。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>正如现代</span><span lang=EN-US>x86
CPU</span><span style='font-family:微软雅黑'>宏观上是冯・诺依曼结构，而微观上又采用了哈佛结构一样，它们从外面看起来是</span><span
lang=EN-US>CISC</span><span style='font-family:微软雅黑'>，内里却怀着一颗</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>心：</span><span lang=EN-US>x86
CPU</span><span style='font-family:微软雅黑'>执行指令前先译码，得到更低级的类似</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>的微代码（</span><span
lang=EN-US>microcode</span><span style='font-family:微软雅黑'>）然后执行。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h3><span lang=EN-US>OISC &amp; ZISC</span></h3>

<p class=MsoNormal><span style='font-family:微软雅黑'>小明读了一篇公众号文章，不禁感叹：原来</span><span
lang=EN-US>Intel CPU</span><span style='font-family:微软雅黑'>内部隐藏着“</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>”！看来还是</span><span
lang=EN-US>RISC</span><span style='font-family:微软雅黑'>架构高级，精减的才是最好的。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>岂不知还有比</span><span lang=EN-US>RISC</span><span
style='font-family:微软雅黑'>更精减的终极精减指令集计算机（</span><span lang=EN-US>URISC</span><span
style='font-family:微软雅黑'>），只有一条指令，所以也可以称作</span><span lang=EN-US>OISC</span><span
style='font-family:微软雅黑'>。虽然只有一条指令，但是它也是图灵完备的：</span><span lang=EN-US>Intel i7</span><span
style='font-family:微软雅黑'>或者至强处理器能干的，</span><span lang=EN-US>OISC</span><span
style='font-family:微软雅黑'>同样可以，但程序要长一些。</span><span lang=EN-US>OISC</span><span
style='font-family:微软雅黑'>有很多形式，例如</span> <span style='font-family:微软雅黑'>“</span><span
lang=EN-US>SUBleq</span><span style='font-family:微软雅黑'>”（相减并当结果小于等于</span><span
lang=EN-US>0</span><span style='font-family:微软雅黑'>时跳转）。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>把硕果仅存的一条指令再精减掉就得到了所谓的零指令集计算机（</span><span
lang=EN-US>ZISC</span><span style='font-family:微软雅黑'>），新近出现的一些神经网络处理器就属于此种类型。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h2><span style='font-family:微软雅黑'>三、手机</span><span lang=EN-US>CPU</span><span
style='font-family:微软雅黑'>谁最强？</span></h2>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>说了这么多，那么到底哪款</span><span
lang=EN-US>CPU</span><span style='font-family:微软雅黑'>最强？或者说，对于基于</span><span
lang=EN-US>ARM</span><span style='font-family:微软雅黑'>架构的应用处理器，哪些因素会影响到处理性能？</span></p>

<h3><span lang=EN-US>ARM</span><span style='font-family:微软雅黑'>是谁？</span></h3>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><img
border=0 width=186 height=87 id="图片 1" src="走进终端之最强大脑_v1.2.files/image004.png"
alt="ARM logo.svg"></span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>分析之前需要先澄清一个问题，到底</span><span
lang=EN-US>ARM</span><span style='font-family:微软雅黑'>是什么？</span><span lang=EN-US>ARM</span><span
style='font-family:微软雅黑'>是一家英国公司的名称，是一种指令集，是一种处理器架构，也是一种产品。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>ARM</span><span style='font-family:微软雅黑'>架构整体可分为</span><span
lang=EN-US>64</span><span style='font-family:微软雅黑'>位、</span><span lang=EN-US>32</span><span
style='font-family:微软雅黑'>位两种，</span><span lang=EN-US>32</span><span
style='font-family:微软雅黑'>位架构又可分为新式的</span><span lang=EN-US>Cortex</span><span
style='font-family:微软雅黑'>和老架构两种。老</span><span lang=EN-US>32</span><span
style='font-family:微软雅黑'>位架构分为</span><span lang=EN-US>AMRv2</span><span
style='font-family:微软雅黑'>、……、</span><span lang=EN-US>ARMv6</span><span
style='font-family:微软雅黑'>等多个版本，新</span><span lang=EN-US>32</span><span
style='font-family:微软雅黑'>位</span><span lang=EN-US>Cortex</span><span
style='font-family:微软雅黑'>架构分为</span><span lang=EN-US>ARMv6-M</span><span
style='font-family:微软雅黑'>、</span><span lang=EN-US>ARMv7-A</span><span
style='font-family:微软雅黑'>、</span><span lang=EN-US>ARMv7-M</span><span
style='font-family:微软雅黑'>等多个版本，</span><span lang=EN-US>64</span><span
style='font-family:微软雅黑'>位架构也分为</span><span lang=EN-US>ARMv8-A</span><span
style='font-family:微软雅黑'>、</span><span lang=EN-US>ARMv8.1-A</span><span
style='font-family:微软雅黑'>、</span><span lang=EN-US>ARMv8.2-A</span><span
style='font-family:微软雅黑'>、</span><span lang=EN-US>ARMv8.3-A</span><span
style='font-family:微软雅黑'>等版本，</span><span lang=EN-US>64</span><span
style='font-family:微软雅黑'>位架构向下兼容</span><span lang=EN-US>32</span><span
style='font-family:微软雅黑'>位的</span><span lang=EN-US>ARMv7-A</span><span
style='font-family:微软雅黑'>架构。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>一种版本的架构下，又有不同厂家设计出性能各异的产品，例如采用</span><span
lang=EN-US>AMRv8-A</span><span style='font-family:微软雅黑'>架构的处理器产品有：</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>AMR Cortex-A53</span><span style='font-family:
微软雅黑'>：</span><span lang=EN-US>8</span><span style='font-family:微软雅黑'>级流水线，</span><span
lang=EN-US>2</span><span style='font-family:微软雅黑'>路超标量（部分指令可双发射），注重省电特性，多充当小核角色</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>AMR Cortex-A57</span><span style='font-family:
微软雅黑'>：</span><span lang=EN-US>15</span><span style='font-family:微软雅黑'>级流水线，支持乱序执行、分支预测，</span><span
lang=EN-US>3</span><span style='font-family:微软雅黑'>路超标量</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>AMR Cortex-A72</span><span style='font-family:
微软雅黑'>：</span><span lang=EN-US>15</span><span style='font-family:微软雅黑'>级流水线，</span><span
lang=EN-US>A57</span><span style='font-family:微软雅黑'>的升级替代</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>AMR Cortex-A73</span><span style='font-family:
微软雅黑'>：</span><span lang=EN-US>11~12</span><span style='font-family:微软雅黑'>级流水线，</span><span
lang=EN-US>A72</span><span style='font-family:微软雅黑'>的升级替代</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>AMR Cortex-A75</span><span style='font-family:
微软雅黑'>：</span><span lang=EN-US>11~13</span><span style='font-family:微软雅黑'>级流水线，</span><span
lang=EN-US>A72</span><span style='font-family:微软雅黑'>的升级替代，增加了</span><span
lang=EN-US>L3</span><span style='font-family:微软雅黑'>缓存，主频最高可达</span><span
lang=EN-US>2.8GHz</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US>Apple A</span><span style='font-family:微软雅黑'>系列：</span><span
lang=EN-US>A10</span><span style='font-family:微软雅黑'>采用</span><span lang=EN-US>16</span><span
style='font-family:微软雅黑'>级流水线，支持乱序执行，配备</span><span lang=EN-US>L1/L2/L3</span><span
style='font-family:微软雅黑'>缓存，采用</span><span lang=EN-US>2+2</span><span
style='font-family:微软雅黑'>的大小核架构；</span><span lang=EN-US>A11</span><span
style='font-family:微软雅黑'>中包含</span><span lang=EN-US>2</span><span
style='font-family:微软雅黑'>个高性能核心，</span><span lang=EN-US>4</span><span
style='font-family:微软雅黑'>个高效率核心</span></p>

<p class=MsoListParagraph style='margin-left:21.0pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:微软雅黑'>三星</span><span lang=EN-US>Exynos</span><span
style='font-family:微软雅黑'>系列</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>提高</span><span lang=EN-US>CPU</span><span
style='font-family:微软雅黑'>性能的方法无外乎</span> <span style='font-family:微软雅黑'>“多拉快跑”。“快跑”就是要提高时钟频率，而“多拉”的方法则有很多。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h3><span style='font-family:微软雅黑'>多核</span></h3>

<p class=MsoNormal><span style='font-family:微软雅黑'>处理内包含多个核心，同时工作处理能力成倍提升，所以</span><span
lang=EN-US>ARM AP</span><span style='font-family:微软雅黑'>从单核、双核发展到现在的四核、八核乃至十核。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>ARM</span><span style='font-family:微软雅黑'>为了兼顾性能与功耗，设计了大小核（</span><span
lang=EN-US>big.LITTLE</span><span style='font-family:微软雅黑'>，确切说应该翻译为</span><span
style='font-size:6.5pt;font-family:微软雅黑'>大</span><b><span style='font-family:
微软雅黑'>小</span></b><span style='font-family:微软雅黑'>核）异构计算架构，需要高性能时用大核以保证处理速度，不需要高性能时用小核以节省功耗。从操作系统的多核调度看，有三种迁移策略。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:18.0pt;text-indent:-18.0pt'><span
lang=EN-US>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:微软雅黑'>簇间切换（</span><span lang=EN-US>Clustered
Switching</span><span style='font-family:微软雅黑'>）：将大核组成一个簇，小核另一个簇，每个簇中的核心数目相同。操作系统根据当前的负荷情况在两个簇间切换，不用的簇将被下电；</span></p>

<p class=MsoListParagraph style='margin-left:18.0pt;text-indent:0cm'><span
lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:18.0pt;text-indent:0cm'>
<img src="走进终端之最强大脑_v1.1.files/ani2.gif" width=400 /></p>

<p class=MsoListParagraph style='margin-left:18.0pt;text-indent:0cm'><span
lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:18.0pt;text-indent:-18.0pt'><span
lang=EN-US>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:微软雅黑'>核内开关（</span><span lang=EN-US>In-kernel
Switcher</span><span style='font-family:微软雅黑'>）：将大核和小核配对，每一对构成一个虚拟核心，一个虚拟核心内要么大核工作要么小核工作；操作系统根据负荷情况调整每个虚拟核心的工作状态；</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:18.0pt;text-indent:0cm'>
<img src="走进终端之最强大脑_v1.1.files/ani3.gif"  width=400 /></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:18.0pt;text-indent:-18.0pt'><span
lang=EN-US>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:微软雅黑'>异构多处理（</span><span lang=EN-US>HMP</span><span
style='font-family:微软雅黑'>）或全局任务调度（</span><span lang=EN-US>GTS</span><span
style='font-family:微软雅黑'>）：操作系统可以直接控制所有核心的工作状态，根据各个线程对处理能力的需求自动将它们分配到大核或者小核上。这种调度方法最为灵活，但是这样的异构体系也对操作系统的调度策略提出很高的要求。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoListParagraph style='margin-left:18.0pt;text-indent:0cm'>
<img src="走进终端之最强大脑_v1.1.files/ani4.gif"  width=400 /></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>问题：是否核心数越多，用户体验越好？</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>答：不一定。如果应用是单线程的，那么即便</span><span
lang=EN-US>AP</span><span style='font-family:微软雅黑'>里有</span><span lang=EN-US>100</span><span
style='font-family:微软雅黑'>个核心，也只能由</span><span lang=EN-US>1</span><span
style='font-family:微软雅黑'>个核心独挑大梁，另外</span><span lang=EN-US>99</span><span
style='font-family:微软雅黑'>个爱莫能助。具体到</span><span lang=EN-US>Android</span><span
style='font-family:微软雅黑'>，因为它的显示系统</span><span lang=EN-US>SurfaceFlinger</span><span
style='font-family:微软雅黑'>单独属于一个线程，所以一个应用至少会到</span><span lang=EN-US>2</span><span
style='font-family:微软雅黑'>个线程，双核</span><span lang=EN-US>CPU</span><span
style='font-family:微软雅黑'>值得拥有。</span></p>

<h3><span style='font-family:微软雅黑'>流水线</span></h3>

<p class=MsoNormal><span style='font-family:微软雅黑'>将一条指令的执行比做生产一个产品，采用流水线生产可以达到同时利用处理器内部各种资源的效果，提高效率。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>比如下面的</span><span lang=EN-US>5</span><span
style='font-family:微软雅黑'>级流水线：取指（</span><span lang=EN-US>IF</span><span
style='font-family:微软雅黑'>）、解码（</span><span lang=EN-US>ID</span><span
style='font-family:微软雅黑'>）、执行（</span><span lang=EN-US>EX</span><span
style='font-family:微软雅黑'>）、内存存取（</span><span lang=EN-US>MEM</span><span
style='font-family:微软雅黑'>）、寄存器回写（</span><span lang=EN-US>WB</span><span
style='font-family:微软雅黑'>）。每条指令需要经过这个</span><span lang=EN-US>5</span><span
style='font-family:微软雅黑'>个小步骤才能真正执行完毕。图中，高亮的一列里，处理器的取指、解码、执行、内存存取、寄存器回写等相关的功能模块同时运作，利用率高；另一方面，第</span><span
lang=EN-US>1</span><span style='font-family:微软雅黑'>条指令已执行完毕，第</span><span
lang=EN-US>3</span><span style='font-family:微软雅黑'>条正在执行，第</span><span lang=EN-US>5</span><span
style='font-family:微软雅黑'>条指令则正在读取当中。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=401 height=142 id="图片 4"
src="走进终端之最强大脑_v1.2.files/image005.png"></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p style='margin-left:0.0pt;text-indent:0cm'>
<img src="走进终端之最强大脑_v1.1.files/ani1.gif"  width=400 /></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>敏锐的读者是否已发现问题？假设第</span><span
lang=EN-US>1</span><span style='font-family:微软雅黑'>条指令是一条跳转指令，执行完毕后要跳到到第</span><span
lang=EN-US>10</span><span style='font-family:微软雅黑'>条指令，第</span><span lang=EN-US>2</span><span
style='font-family:微软雅黑'>、</span><span lang=EN-US>3</span><span style='font-family:
微软雅黑'>、</span><span lang=EN-US>4</span><span style='font-family:微软雅黑'>、</span><span
lang=EN-US>5</span><span style='font-family:微软雅黑'>条已经送入流水线了，这可如何是好？一个比较笨的办法是遇到分支跳转指令时，其后的指令先不取指，流水线先暂停，先把这条分支跳转指令执行完毕再说。流水线不“流”了，效率大大折扣。改进思路就是进行<b>分支预测</b>，处理器根据过往信息推测分支指令的执行情况，提前把目标位置的指令送入流水线。为获得较好的预测效果，各大厂家无所不用其极，</span><span
lang=EN-US>AMD</span><span style='font-family:微软雅黑'>公司</span><span lang=EN-US>2016</span><span
style='font-family:微软雅黑'>年底推出的翻身大作</span><span lang=EN-US>Ryzen</span><span
style='font-family:微软雅黑'>甚至使用了神经网络。</span><span lang=EN-US>[1]</span><span
style='font-family:微软雅黑'>总结了从公元前</span><span lang=EN-US>150</span><span
style='font-family:微软雅黑'>万年到今天分支预测技术的完整发展历程。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>假如第</span><span lang=EN-US>3</span><span
style='font-family:微软雅黑'>条指令</span><span lang=EN-US>EX</span><span
style='font-family:微软雅黑'>时需要第</span><span lang=EN-US>2</span><span
style='font-family:微软雅黑'>条指令完成内存存取（</span><span lang=EN-US>MEM</span><span
style='font-family:微软雅黑'>），而第</span><span lang=EN-US>4</span><span
style='font-family:微软雅黑'>条指令没有这个要求，我们可以先把第</span><span lang=EN-US>4</span><span
style='font-family:微软雅黑'>条指令送入流水线，然后送入第</span><span lang=EN-US>3</span><span
style='font-family:微软雅黑'>条指令，这就叫做<b>乱序执行</b>。要正确地乱序执行，必须分析各条指令的依赖关系，需要设计非常复杂的逻辑电路，成本很高。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=401 height=142 id="图片 5"
src="走进终端之最强大脑_v1.2.files/image006.png"></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h3><span style='font-family:微软雅黑'>超标量</span></h3>

<p class=MsoNormal><span style='font-family:微软雅黑'>一个核心内部一般只有一个算术逻辑单元（</span><span
lang=EN-US>ALU</span><span style='font-family:微软雅黑'>），如果再增加一个，这样就是同时处理两条运算指令了，这就得到了所谓的超标量处理器。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>一个双发射的超标量处理器可以看成有两条流水线同时工作，可以同时执行两条指令。如图中高亮部分，第</span><span
lang=EN-US>5</span><span style='font-family:微软雅黑'>、</span><span lang=EN-US>6</span><span
style='font-family:微软雅黑'>条指令正同时执行。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US><img border=0 width=301 height=142 id="图片 6"
src="走进终端之最强大脑_v1.2.files/image007.png"></span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<h3><span lang=EN-US>SIMD</span></h3>

<p class=MsoNormal><span style='font-family:微软雅黑'>因为可以同时完成多个标量计算，所以得名“超标量”。换一种思路，也可以直接在处理器里增加向量运算能力，这就是单指令多数据（</span><span
lang=EN-US>SIMD</span><span style='font-family:微软雅黑'>）技术。从较早的仅支持整数运算的奔腾</span><span
lang=EN-US>MMX</span><span style='font-family:微软雅黑'>指令集，到后来的</span><span
lang=EN-US>SSE</span><span style='font-family:微软雅黑'>、</span><span lang=EN-US>SSE2</span><span
style='font-family:微软雅黑'>、……以及</span><span lang=EN-US>ARM</span><span
style='font-family:微软雅黑'>公司设计的</span><span lang=EN-US>NEON</span><span
style='font-family:微软雅黑'>指令集，</span> <span style='font-family:微软雅黑'>都属于</span><span
lang=EN-US>SIMD</span><span style='font-family:微软雅黑'>技术。它们为多媒体数据能力的提升立下汗马功劳。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>下图是</span><span lang=EN-US>SSE2</span><span
style='font-family:微软雅黑'>中压缩单精度浮点乘法（</span><span lang=EN-US>MULPS</span><span
style='font-family:微软雅黑'>）指令示意。</span><span lang=EN-US>MULPS</span><span
style='font-family:微软雅黑'>指令把</span><span lang=EN-US>128</span><span
style='font-family:微软雅黑'>比特长的向量寄存器</span><span lang=EN-US>XMMx</span><span
style='font-family:微软雅黑'>视为</span><span lang=EN-US>4</span><span
style='font-family:微软雅黑'>个单精度浮点数，依次相乘，一条指令处理了四组数据。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><img
border=0 width=441 height=251 src="走进终端之最强大脑_v1.2.files/image008.png"></span></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>回到我们的问题：手机</span><span
lang=EN-US>CPU</span><span style='font-family:微软雅黑'>，到底谁家强？不单要看频率、核心数，也要看各级缓存大不大，流水线设计好不好，分支预测行不行，乱序执行牛不牛，多发射强不强，</span><span
lang=EN-US>SIMD</span><span style='font-family:微软雅黑'>指令多不多，等等。或许，还是跑个分吧？但要注意，能让</span><span
lang=EN-US>4</span><span style='font-family:微软雅黑'>核、</span><span lang=EN-US>8</span><span
style='font-family:微软雅黑'>核全部长时间满负荷运转的应用除了跑分软件之外并不多见，所以多核分数仅做参考，“跑分不重要，关键看疗效”。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:微软雅黑'>参考资料：</span></p>

<p class=MsoNormal><span lang=EN-US>[1] &nbsp; https://danluu.com/branch-prediction</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

</div>

</body>

</html>
